
# Касовий апарат: алгоритми видачі решти

Цей проект реалізує два алгоритми для визначення оптимального способу видачі решти покупцеві: **жадібний алгоритм** і **динамічне програмування**. Алгоритми порівнюються за ефективністю, вимірюючи час їх виконання для кожної суми, що вводиться користувачем.

## Опис функціоналу

### 1. Жадібний алгоритм
- Алгоритм використовує найбільші доступні номінали монет для формування суми.
- Повертає словник, який містить номінали монет і їх кількість для досягнення заданої суми.

### 2. Алгоритм динамічного програмування
- Алгоритм знаходить мінімальну кількість монет для формування суми.
- Повертає словник, який містить номінали монет і їх кількість для досягнення заданої суми з мінімальними витратами.

## Порівняння ефективності алгоритмів

У цьому проекті ми порівнюємо ефективність **жадібного алгоритму** та **алгоритму динамічного програмування**, зокрема їх **час виконання** та **складність** в контексті великих сум.

### Оцінка часу виконання:
1. **Жадібний алгоритм**:
   - Складність: **O(n)**, де `n` — сума, що потрібно видати.
   - Алгоритм працює швидше для малих сум, оскільки він просто вибирає найбільші монети і формує суму.
   
2. **Динамічне програмування**:
   - Складність: **O(n * m)**, де `n` — сума, а `m` — кількість доступних номіналів монет.
   - Алгоритм дає оптимальний результат для мінімалізації кількості монет, але потребує більше часу для великих сум, оскільки необхідно побудувати таблицю для кожної суми до досягнення заданої суми.

### Продуктивність при великих сумах:
- Для великих сум **жадібний алгоритм** є більш ефективним у плані часу, оскільки його складність лінійна, і він працює швидше, вибираючи монети без необхідності обчислювати всі можливі варіанти.
- **Динамічне програмування** показує свою перевагу, коли потрібен мінімальний набір монет для досягнення суми, але його складність зростає з розміром суми та кількістю доступних номіналів, що робить його менш ефективним для великих значень.

## Висновки

### 1. **Жадібний алгоритм**:
- **Переваги**:
  - **Швидкість**: Жадібний алгоритм має **лінійну складність** **O(n)**, що робить його дуже швидким для малих і середніх сум. Алгоритм лише вибирає найбільші монети, поки не буде досягнута необхідна сума, що робить його дуже ефективним у простих випадках.
  - **Простота реалізації**: Код жадібного алгоритму дуже простий і не потребує складних обчислень. Це дозволяє йому швидко працювати, навіть при обмежених ресурсах.

- **Недоліки**:
  - **Не завжди оптимальний**: Жадібний алгоритм може не знаходити оптимальне рішення в деяких випадках. Наприклад, коли для досягнення суми потрібен певний набір монет, який не обирається за допомогою жадібного підходу. Він вибирає найбільшу монету, не враховуючи, що інші монети можуть призвести до кращого результату в плані мінімальної кількості монет.
  - **Можлива надмірність монет**: У деяких випадках жадібний алгоритм може вибирати більше монет, ніж потрібно, оскільки він не аналізує всі можливі варіанти.

### 2. **Динамічне програмування**:
- **Переваги**:
  - **Оптимальність**: Динамічне програмування гарантує мінімальну кількість монет для будь-якої суми. Це дає можливість використовувати монети в найбільш ефективний спосіб, навіть якщо деякі номінали монет не можуть бути використані жадібним алгоритмом.
  - **Гнучкість**: Цей підхід працює в більш складних випадках, коли потрібно точне оптимальне рішення, і дає можливість працювати з монетами, де жадібний алгоритм зазнає труднощів.

- **Недоліки**:
  - **Часова складність**: Алгоритм динамічного програмування має складність **O(n * m)**, де `n` — сума, а `m` — кількість доступних номіналів монет. Це означає, що алгоритм стає повільним при великих сумах або великій кількості монет, оскільки потрібно побудувати таблицю для кожної суми та кожної монети.
  - **Використання пам'яті**: Для зберігання таблиць потрібна додаткова пам'ять, що може бути проблемою при великих сумах або обмеженому обсязі пам'яті.

### 3. **Порівняння ефективності**:
- **Жадібний алгоритм** є більш ефективним за часом виконання для **малих і середніх сум**, оскільки має лінійну складність **O(n)**. Він дуже швидко дає результат для таких випадків, особливо якщо номінали монет добре підходять для жадібного підходу.
- **Динамічне програмування** показує свою перевагу в **складних випадках**, де необхідно мінімізувати кількість монет, але його час виконання зростає значно з великими сумами та великим набором монет. Для великих суми і великої кількості номіналів монет цей алгоритм може бути набагато повільнішим.
  
### 4. **Рекомендації**:
- **Для малих сум або простих задач**, де не потрібно обчислювати оптимальну кількість монет, краще використовувати **жадібний алгоритм**. Його швидкість і простота реалізації роблять його ідеальним вибором у таких випадках.
- **Для складних задач** або **великих сум**, коли важливо отримати оптимальний результат з мінімальною кількістю монет, доцільно використовувати **динамічне програмування**. Незважаючи на більшу складність, він гарантує оптимальний результат і дає можливість працювати з більш складними наборами монет.

### 5. **Різниця в часі для великих сум**:
- **Жадібний алгоритм** значно швидший при великих сумах, оскільки не потрібно виконувати додаткові перевірки та обчислення для кожної суми.
- **Динамічне програмування** стає значно менш ефективним при великих сумах через необхідність побудови таблиць для кожної можливої суми. Однак для задач, де необхідно знайти мінімальну кількість монет для дуже великої суми з обмеженими номіналами, алгоритм динамічного програмування є незамінним.

### 6. **Складність обох алгоритмів**:
- **Жадібний алгоритм**: має **лінійну складність** **O(n)**, що робить його ідеальним для швидких обчислень при малих і середніх значеннях сум.
- **Динамічне програмування**: має **квадратичну складність** **O(n * m)**, що робить його менш ефективним при великих сумах або великій кількості монет.

## Особливості роботи скрипта
- Користувач може вибирати валюту з доступного списку.
- Можна вводити одну або кілька сум для обчислення решти.
- Для кожної суми порівнюється час виконання обох алгоритмів, і виводиться їхня різниця та відсоткова ефективність.
- Результати логуються у файл `log.txt`.

## Алгоритми
### Жадібний алгоритм:
- Складність: **O(n)**, де `n` — це сума, що потрібно видати.
- Алгоритм вибирає монети від найбільшого до найменшого номіналу, поки не буде сформована сума.

### Динамічне програмування:
- Складність: **O(n * m)**, де `n` — це сума, а `m` — кількість доступних номіналів монет.
- Алгоритм знаходить мінімальну кількість монет для кожної суми за допомогою таблиці, в якій для кожної суми зберігається мінімальна кількість монет.

## Використання

### Запуск скрипта
1. Клонувати репозиторій:
   ```
   git clone https://github.com/mxmz-code/goit-algo-hw-09.git
   ```
2. Перейти до папки з репозиторієм:
   ```
   cd goit-algo-hw-09
   ```
3. Запустити скрипт:
   ```
   python main.py
   ```

### Інтерфейс
1. Користувач вводить суму або кілька сум через пробіл або кому.
2. Вибирає валюту (наприклад, GOIT, USD, EUR, GBP).
3. Скрипт обчислює кількість монет за допомогою жадібного алгоритму та алгоритму динамічного програмування, порівнює час їх виконання і виводить результати.
4. Результати записуються в лог-файл `log.txt`.
